<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>四邊形動畫學習器</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Microsoft JhengHei', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }

        .header {
            color: white;
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.2em;
            opacity: 0.9;
        }

        .controls {
            display: flex;
            gap: 15px;
            margin-bottom: 30px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .shape-btn {
            padding: 12px 20px;
            border: none;
            border-radius: 25px;
            background: white;
            color: #333;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }

        .shape-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
        }

        .shape-btn.active {
            background: #ffd700;
            color: #333;
        }

        .animation-container {
            background: white;
            border-radius: 20px;
            padding: 40px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.2);
            max-width: 900px;
            width: 100%;
        }

        .shape-display {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            min-height: 300px;
        }

        .shape-area {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
        }

        .shape {
            transition: all 0.8s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
        }

        .shape.morphing {
            animation: morph 1.5s ease-in-out;
        }

        .shape.transforming {
            transition: all 2s cubic-bezier(0.4, 0, 0.2, 1);
        }

        @keyframes morph {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1) rotate(5deg); }
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); filter: brightness(1); }
            50% { transform: scale(1.05); filter: brightness(1.2); }
        }

        .shape.animating {
            animation: pulse 0.5s ease-in-out;
        }

        .properties-panel {
            flex: 1;
            margin-left: 40px;
            background: #f8f9ff;
            border-radius: 15px;
            padding: 25px;
        }

        .properties-panel h3 {
            color: #333;
            margin-bottom: 20px;
            font-size: 1.4em;
        }

        .property {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
            padding: 10px;
            background: white;
            border-radius: 8px;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .property.highlight {
            background: #e8f5e8;
            transform: scale(1.02);
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .property:hover {
            background: #f0f8ff;
            transform: scale(1.01);
        }

        .property-icon {
            width: 20px;
            height: 20px;
            margin-right: 10px;
            border-radius: 50%;
        }

        .parallel { background: #4CAF50; }
        .equal { background: #2196F3; }
        .right-angle { background: #FF9800; }
        .diagonal { background: #9C27B0; }

        /* SVG 視覺元素樣式 */
        .visual-element {
            opacity: 0.3;
            transition: all 0.5s ease;
        }

        .visual-element.highlight {
            opacity: 1;
            filter: drop-shadow(0 0 3px currentColor);
        }

        .parallel-mark {
            stroke: #4CAF50;
            stroke-width: 2;
            fill: none;
        }

        .equal-mark {
            stroke: #2196F3;
            stroke-width: 2;
            fill: none;
        }

        .angle-mark {
            stroke: #FF9800;
            stroke-width: 2;
            fill: none;
        }

        .general-angle-mark {
            stroke: #FF9800;
            stroke-width: 2;
            fill: none;
        }

        .diagonal-line {
            stroke: #9C27B0;
            stroke-width: 1.5;
            stroke-dasharray: 3,3;
            fill: none;
        }

        .relationship-network {
            margin-top: 30px;
            text-align: center;
        }

        .relationship-network h3 {
            margin-bottom: 20px;
            color: #333;
        }

        .animation-controls {
            text-align: center;
            margin: 15px 0 0 0;
            padding: 15px;
            background: #f8f9ff;
            border-radius: 10px;
            border: 2px dashed #ddd;
            width: 100%;
            max-width: 250px;
        }

        .animate-transformation-btn {
            background: linear-gradient(45deg, #ff6b6b, #feca57);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 15px;
            font-size: 13px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }

        .animate-transformation-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }

        .animate-transformation-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .transformation-progress {
            width: 100%;
            height: 4px;
            background: #e0e0e0;
            border-radius: 2px;
            margin-top: 8px;
            overflow: hidden;
        }

        .relationship-info {
            background: #fff3cd;
            border: 2px solid #ffc107;
            border-radius: 10px;
            padding: 15px;
            margin: 15px 0;
            text-align: center;
            min-height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }

        .relationship-info.hidden {
            opacity: 0.5;
            background: #f8f9fa;
            border-color: #dee2e6;
        }

        .relationship-info h4 {
            margin: 0;
            color: #856404;
            font-size: 14px;
            line-height: 1.4;
        }

        .relationship-info.transformation {
            background: #e8f5e8;
            border-color: #4CAF50;
        }

        .relationship-info.transformation h4 {
            color: #2e7d32;
        }

        .relationship-info.hidden h4 {
            color: #6c757d;
        }

        .network-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            height: 120px;
            margin: 0 auto;
            background: #f8f9ff;
            border-radius: 15px;
            padding: 20px;
            box-sizing: border-box;
        }

        .shape-node {
            padding: 12px 18px;
            font-weight: bold;
            font-size: 14px;
            transition: all 0.3s ease;
            cursor: pointer;
            z-index: 2;
            border: 2px solid #333;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 3px 8px rgba(0,0,0,0.2);
            position: relative;
        }

        .shape-node.trapezoid { 
            background: #ddbdff; 
            color: #333; 
            width: 90px;
            height: 55px;
            clip-path: polygon(20% 0%, 80% 0%, 100% 100%, 0% 100%);
            border: none;
            font-size: 13px;
        }
        
        .shape-node.parallelogram { 
            background: #ffecb3; 
            color: #333; 
            width: 95px;
            height: 55px;
            transform: skewX(-20deg);
        }
        
        .shape-node.parallelogram span {
            transform: skewX(20deg);
            display: block;
            font-size: 12px;
        }
        
        .shape-node.rectangle { 
            background: #c8e6c9; 
            color: #333; 
            width: 85px;
            height: 55px;
            border-radius: 0;
        }
        
        .shape-node.rhombus { 
            background: #f8bbd9; 
            color: #333; 
            width: 60px;
            height: 60px;
            transform: rotate(45deg);
            border-radius: 0;
        }
        
        .shape-node.rhombus span {
            transform: rotate(-45deg);
            display: block;
            font-size: 13px;
        }
        
        .shape-node.square { 
            background: #ffd54f; 
            color: #333; 
            width: 60px;
            height: 60px;
            border-radius: 0;
        }

        .shape-node:hover {
            box-shadow: 0 8px 20px rgba(0,0,0,0.3);
            z-index: 3;
            transform: scale(1.1);
        }

        .shape-node.parallelogram:hover {
            transform: skewX(-20deg) scale(1.1);
        }

        .shape-node.rhombus:hover {
            transform: rotate(45deg) scale(1.1);
        }

        .shape-node.active {
            color: white !important;
            box-shadow: 0 0 20px rgba(76, 175, 80, 0.8);
            transform: scale(1.1);
            z-index: 4;
        }

        .shape-node.active.parallelogram {
            transform: skewX(-20deg) scale(1.1);
        }

        .shape-node.active.rhombus {
            transform: rotate(45deg) scale(1.1);
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #2196F3);
            width: 0%;
            transition: width 0.1s ease;
            border-radius: 2px;
        }

        .animate-btn {
            background: linear-gradient(45deg, #ff6b6b, #feca57);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 25px;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            margin: 20px auto;
            display: block;
            transition: all 0.3s ease;
        }

        .animate-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(0,0,0,0.2);
        }

        @media (max-width: 768px) {
            .shape-display {
                flex-direction: column;
            }
            
            .properties-panel {
                margin-left: 0;
                margin-top: 20px;
            }
            
            .network-container {
                flex-wrap: wrap;
                height: auto;
                gap: 15px;
                justify-content: center;
                padding: 15px;
            }
            
            .shape-node {
                margin: 5px;
            }
            
            .shape-node.parallelogram span,
            .shape-node.rhombus span {
                font-size: 11px;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>🔷 四邊形探索樂園 🔷</h1>
        <p>發現各種四邊形的奇妙特性和它們之間的關係！</p>
    </div>

    <div class="controls">
        <button class="shape-btn active" data-shape="square">正方形</button>
        <button class="shape-btn" data-shape="rectangle">長方形</button>
        <button class="shape-btn" data-shape="rhombus">菱形</button>
        <button class="shape-btn" data-shape="parallelogram">平行四邊形</button>
        <button class="shape-btn" data-shape="trapezoid">梯形</button>
    </div>

    <div class="animation-container">
        <div class="shape-display">
            <div class="shape-area">
                <svg id="shape-svg" width="250" height="250" viewBox="0 0 250 250">
                    <polygon id="main-shape" points="" fill="#4CAF50" stroke="#333" stroke-width="3"/>
                    
                    <!-- 平行線標記 -->
                    <g id="parallel-marks" class="visual-element">
                        <g class="parallel-mark" data-type="parallel">
                            <line id="parallel1a" x1="0" y1="0" x2="0" y2="0" />
                            <line id="parallel1b" x1="0" y1="0" x2="0" y2="0" />
                            <line id="parallel2a" x1="0" y1="0" x2="0" y2="0" />
                            <line id="parallel2b" x1="0" y1="0" x2="0" y2="0" />
                        </g>
                    </g>
                    
                    <!-- 直角標記 -->
                    <g id="angle-marks" class="visual-element">
                        <g class="angle-mark" data-type="right-angle">
                            <rect id="angle1" x="0" y="0" width="15" height="15" />
                            <rect id="angle2" x="0" y="0" width="15" height="15" />
                            <rect id="angle3" x="0" y="0" width="15" height="15" />
                            <rect id="angle4" x="0" y="0" width="15" height="15" />
                        </g>
                    </g>
                    
                    <!-- 非直角標記（菱形、平行四邊形用） -->
                    <g id="angle-marks-general" class="visual-element">
                        <g class="general-angle-mark" data-type="general-angle">
                            <circle id="angle-dot1" cx="0" cy="0" r="0" fill="#FF9800" />
                            <circle id="angle-dot2" cx="0" cy="0" r="0" fill="#FF9800" />
                            <circle id="angle-dot3" cx="0" cy="0" r="0" fill="#FF9800" />
                            <circle id="angle-dot4" cx="0" cy="0" r="0" fill="#FF9800" />
                        </g>
                    </g>
                    
                    <!-- 相等邊標記 -->
                    <g id="equal-marks" class="visual-element">
                        <g class="equal-mark" data-type="equal">
                            <line id="equal1a" x1="0" y1="0" x2="0" y2="0" />
                            <line id="equal1b" x1="0" y1="0" x2="0" y2="0" />
                            <line id="equal2a" x1="0" y1="0" x2="0" y2="0" />
                            <line id="equal2b" x1="0" y1="0" x2="0" y2="0" />
                            <line id="equal3a" x1="0" y1="0" x2="0" y2="0" />
                            <line id="equal3b" x1="0" y1="0" x2="0" y2="0" />
                            <line id="equal4a" x1="0" y1="0" x2="0" y2="0" />
                            <line id="equal4b" x1="0" y1="0" x2="0" y2="0" />
                        </g>
                    </g>
                    
                    <!-- 梯形兩腰標記 -->
                    <g id="sides-marks" class="visual-element">
                        <g class="equal-mark" data-type="equal-sides">
                            <line id="side1a" x1="0" y1="0" x2="0" y2="0" />
                            <line id="side2a" x1="0" y1="0" x2="0" y2="0" />
                            <line id="side2b" x1="0" y1="0" x2="0" y2="0" />
                        </g>
                    </g>
                    
                    <!-- 對角線 -->
                    <g id="diagonal-marks" class="visual-element">
                        <g class="diagonal-line" data-type="diagonal">
                            <line id="diagonal1" x1="0" y1="0" x2="0" y2="0" />
                            <line id="diagonal2" x1="0" y1="0" x2="0" y2="0" />
                        </g>
                    </g>
                </svg>
                
                <!-- 动画按钮 -->
                <button id="animate-transformation-btn" class="animate-transformation-btn" style="display:none;">
                    🎬 觀看變換動畫
                </button>
                
                <!-- 进度条 -->
                <div class="transformation-progress" style="display:none;">
                    <div class="progress-bar"></div>
                </div>
            </div>

            <div class="properties-panel">
                <h3 id="shape-title">正方形</h3>
                <div id="properties-list">
                    <!-- Properties will be populated by JavaScript -->
                </div>
            </div>
        </div>

        <div class="relationship-network">
            <h3>🔗 四邊形變換</h3>
            
            <!-- 变换信息提示框 -->
            <div class="relationship-info hidden">
                <h4 id="relationship-text">💡 點擊一個形狀作為起點，再點擊另一個形狀查看變換方式</h4>
            </div>
            
            <div class="network-container">
                <!-- 形狀節點 -->
                <div class="shape-node trapezoid" data-shape="trapezoid">梯形</div>
                <div class="shape-node parallelogram" data-shape="parallelogram"><span>平行四邊形</span></div>
                <div class="shape-node rectangle" data-shape="rectangle">長方形</div>
                <div class="shape-node rhombus" data-shape="rhombus"><span>菱形</span></div>
                <div class="shape-node square" data-shape="square">正方形</div>
            </div>
        </div>
    </div>

    <script>
        const shapes = {
            square: {
                points: "75,75 175,75 175,175 75,175",
                title: "正方形",
                properties: [
                    { text: "四條邊都相等", icon: "equal", visual: "equal" },
                    { text: "四個角都是直角", icon: "right-angle", visual: "right-angle" },
                    { text: "對邊平行", icon: "parallel", visual: "parallel" },
                    { text: "對角線相等且垂直", icon: "diagonal", visual: "diagonal" }
                ],
                visualElements: {
                    parallel: { show: true },
                    equal: { show: true },
                    rightAngle: { show: true },
                    diagonal: { show: true }
                }
            },
            rectangle: {
                points: "50,75 200,75 200,175 50,175",
                title: "長方形",
                properties: [
                    { text: "對邊相等", icon: "equal", visual: "equal" },
                    { text: "四個角都是直角", icon: "right-angle", visual: "right-angle" },
                    { text: "對邊平行", icon: "parallel", visual: "parallel" },
                    { text: "對角線相等", icon: "diagonal", visual: "diagonal" }
                ],
                visualElements: {
                    parallel: { show: true },
                    equal: { show: true },
                    rightAngle: { show: true },
                    diagonal: { show: true }
                }
            },
            rhombus: {
                points: "125,70 190,125 125,180 60,125",
                title: "菱形",
                properties: [
                    { text: "四條邊都相等", icon: "equal", visual: "equal" },
                    { text: "對角相等", icon: "right-angle", visual: "general-angle" },
                    { text: "對邊平行", icon: "parallel", visual: "parallel" },
                    { text: "對角線垂直且互相平分", icon: "diagonal", visual: "diagonal" }
                ],
                visualElements: {
                    parallel: { show: true },
                    equal: { show: true },
                    rightAngle: { show: false },
                    generalAngle: { show: true },
                    diagonal: { show: true }
                }
            },
            parallelogram: {
                points: "75,75 175,75 200,175 100,175",
                title: "平行四邊形",
                properties: [
                    { text: "對邊相等", icon: "equal", visual: "equal" },
                    { text: "對角相等", icon: "right-angle", visual: "general-angle" },
                    { text: "對邊平行", icon: "parallel", visual: "parallel" },
                    { text: "對角線互相平分", icon: "diagonal", visual: "diagonal" }
                ],
                visualElements: {
                    parallel: { show: true },
                    equal: { show: true },
                    rightAngle: { show: false },
                    generalAngle: { show: true },
                    diagonal: { show: true }
                }
            },
            trapezoid: {
                points: "75,75 175,75 150,175 100,175",
                title: "梯形",
                properties: [
                    { text: "有一組對邊平行", icon: "parallel", visual: "parallel" },
                    { text: "上底和下底長度不等", icon: "equal", visual: "equal" },
                    { text: "兩腰可能不等", icon: "equal", visual: "equal-sides" }
                ],
                visualElements: {
                    parallel: { show: true, onlyOne: true },
                    equal: { show: true },
                    sides: { show: true },
                    rightAngle: { show: false },
                    diagonal: { show: false }
                }
            }
        };

        let currentShape = 'square';
        let isAnimating = false;

        // 動畫相關變數
        let animationState = {
            sourceShape: null,
            targetShape: null,
            isActive: false
        };

        function updateVisualMarkers(shapeName) {
            const shape = shapes[shapeName];
            if (!shape || !shape.visualElements) return;
            
            const points = shape.points.split(' ').map(p => {
                const [x, y] = p.split(',').map(Number);
                return { x, y };
            });

            // 清除所有標記
            document.querySelectorAll('.visual-element').forEach(el => {
                el.style.display = 'none';
            });

            // 清除所有角度標記
            for (let i = 1; i <= 4; i++) {
                const angleDot = document.getElementById(`angle-dot${i}`);
                if (angleDot) {
                    angleDot.setAttribute('r', '0');
                    angleDot.setAttribute('cx', '0');
                    angleDot.setAttribute('cy', '0');
                }
            }

            // 設置平行線標記
            if (shape.visualElements.parallel.show) {
                const parallelMarks = document.getElementById('parallel-marks');
                parallelMarks.style.display = 'block';
                
                if (shapeName === 'trapezoid') {
                    const topMidX = (points[0].x + points[1].x) / 2;
                    const topMidY = (points[0].y + points[1].y) / 2;
                    const bottomMidX = (points[2].x + points[3].x) / 2;
                    const bottomMidY = (points[2].y + points[3].y) / 2;
                    
                    const parallel1a = document.getElementById('parallel1a');
                    const parallel1b = document.getElementById('parallel1b');
                    if (parallel1a && parallel1b) {
                        parallel1a.setAttribute('x1', topMidX - 8);
                        parallel1a.setAttribute('y1', topMidY - 5);
                        parallel1a.setAttribute('x2', topMidX + 8);
                        parallel1a.setAttribute('y2', topMidY - 5);
                        
                        parallel1b.setAttribute('x1', bottomMidX - 8);
                        parallel1b.setAttribute('y1', bottomMidY + 5);
                        parallel1b.setAttribute('x2', bottomMidX + 8);
                        parallel1b.setAttribute('y2', bottomMidY + 5);
                    }
                    
                    const parallel2a = document.getElementById('parallel2a');
                    const parallel2b = document.getElementById('parallel2b');
                    if (parallel2a && parallel2b) {
                        parallel2a.setAttribute('x1', 0);
                        parallel2a.setAttribute('y1', 0);
                        parallel2a.setAttribute('x2', 0);
                        parallel2a.setAttribute('y2', 0);
                        
                        parallel2b.setAttribute('x1', 0);
                        parallel2b.setAttribute('y1', 0);
                        parallel2b.setAttribute('x2', 0);
                        parallel2b.setAttribute('y2', 0);
                    }
                } else {
                    const topMidX = (points[0].x + points[1].x) / 2;
                    const topMidY = (points[0].y + points[1].y) / 2;
                    const bottomMidX = (points[2].x + points[3].x) / 2;
                    const bottomMidY = (points[2].y + points[3].y) / 2;
                    
                    const parallel1a = document.getElementById('parallel1a');
                    const parallel1b = document.getElementById('parallel1b');
                    if (parallel1a && parallel1b) {
                        parallel1a.setAttribute('x1', topMidX - 8);
                        parallel1a.setAttribute('y1', topMidY - 5);
                        parallel1a.setAttribute('x2', topMidX + 8);
                        parallel1a.setAttribute('y2', topMidY - 5);
                        
                        parallel1b.setAttribute('x1', bottomMidX - 8);
                        parallel1b.setAttribute('y1', bottomMidY + 5);
                        parallel1b.setAttribute('x2', bottomMidX + 8);
                        parallel1b.setAttribute('y2', bottomMidY + 5);
                    }

                    const leftMidX = (points[0].x + points[3].x) / 2;
                    const leftMidY = (points[0].y + points[3].y) / 2;
                    const rightMidX = (points[1].x + points[2].x) / 2;
                    const rightMidY = (points[1].y + points[2].y) / 2;
                    
                    const parallel2a = document.getElementById('parallel2a');
                    const parallel2b = document.getElementById('parallel2b');
                    if (parallel2a && parallel2b) {
                        parallel2a.setAttribute('x1', leftMidX - 5);
                        parallel2a.setAttribute('y1', leftMidY - 8);
                        parallel2a.setAttribute('x2', leftMidX - 5);
                        parallel2a.setAttribute('y2', leftMidY + 8);
                        
                        parallel2b.setAttribute('x1', rightMidX + 5);
                        parallel2b.setAttribute('y1', rightMidY - 8);
                        parallel2b.setAttribute('x2', rightMidX + 5);
                        parallel2b.setAttribute('y2', rightMidY + 8);
                    }
                }
            }

            // 設置直角標記
            if (shape.visualElements.rightAngle.show) {
                const angleMarks = document.getElementById('angle-marks');
                angleMarks.style.display = 'block';
                
                for (let i = 0; i < 4; i++) {
                    const angle = document.getElementById(`angle${i + 1}`);
                    if (angle) {
                        const corner = points[i];
                        angle.setAttribute('x', corner.x - 7.5);
                        angle.setAttribute('y', corner.y - 7.5);
                    }
                }
            }

            // 設置一般角度標記
            if (shape.visualElements.generalAngle && shape.visualElements.generalAngle.show) {
                const angleMarksGeneral = document.getElementById('angle-marks-general');
                angleMarksGeneral.style.display = 'block';
                
                for (let i = 1; i <= 4; i++) {
                    const angleDot = document.getElementById(`angle-dot${i}`);
                    if (angleDot) {
                        angleDot.setAttribute('r', '0');
                        angleDot.setAttribute('cx', '0');
                        angleDot.setAttribute('cy', '0');
                    }
                }
                
                if (shapeName === 'rhombus') {
                    const corner0 = points[0];
                    const corner1 = points[1];
                    const corner2 = points[2];
                    const corner3 = points[3];
                    
                    const dot1 = document.getElementById('angle-dot1');
                    const dot3 = document.getElementById('angle-dot3');
                    if (dot1 && dot3) {
                        dot1.setAttribute('cx', corner0.x);
                        dot1.setAttribute('cy', corner0.y);
                        dot1.setAttribute('r', '3');
                        
                        dot3.setAttribute('cx', corner2.x);
                        dot3.setAttribute('cy', corner2.y);
                        dot3.setAttribute('r', '3');
                    }
                    
                    const dot2 = document.getElementById('angle-dot2');
                    const dot4 = document.getElementById('angle-dot4');
                    if (dot2 && dot4) {
                        dot2.setAttribute('cx', corner1.x);
                        dot2.setAttribute('cy', corner1.y);
                        dot2.setAttribute('r', '5');
                        
                        dot4.setAttribute('cx', corner3.x);
                        dot4.setAttribute('cy', corner3.y);
                        dot4.setAttribute('r', '5');
                    }
                    
                } else if (shapeName === 'parallelogram') {
                    for (let i = 0; i < 4; i++) {
                        const angleDot = document.getElementById(`angle-dot${i + 1}`);
                        if (angleDot) {
                            const corner = points[i];
                            angleDot.setAttribute('cx', corner.x);
                            angleDot.setAttribute('cy', corner.y);
                            
                            if (i === 0 || i === 2) {
                                angleDot.setAttribute('r', '3');
                            } else {
                                angleDot.setAttribute('r', '5');
                            }
                        }
                    }
                }
            } else {
                const angleMarksGeneral = document.getElementById('angle-marks-general');
                if (angleMarksGeneral) {
                    angleMarksGeneral.style.display = 'none';
                }
            }

            // 設置相等邊標記
            if (shape.visualElements.equal.show) {
                const equalMarks = document.getElementById('equal-marks');
                equalMarks.style.display = 'block';
                
                if (shapeName === 'trapezoid') {
                    for (let i = 1; i <= 4; i++) {
                        const equalA = document.getElementById(`equal${i}a`);
                        const equalB = document.getElementById(`equal${i}b`);
                        if (equalA && equalB) {
                            equalA.setAttribute('x1', 0);
                            equalA.setAttribute('y1', 0);
                            equalA.setAttribute('x2', 0);
                            equalA.setAttribute('y2', 0);
                            equalB.setAttribute('x1', 0);
                            equalB.setAttribute('y1', 0);
                            equalB.setAttribute('x2', 0);
                            equalB.setAttribute('y2', 0);
                        }
                    }
                    
                    const topMidX = (points[0].x + points[1].x) / 2;
                    const topMidY = (points[0].y + points[1].y) / 2;
                    const equal1a = document.getElementById('equal1a');
                    if (equal1a) {
                        equal1a.setAttribute('x1', topMidX - 5);
                        equal1a.setAttribute('y1', topMidY - 3);
                        equal1a.setAttribute('x2', topMidX + 5);
                        equal1a.setAttribute('y2', topMidY - 3);
                    }
                    
                    const bottomMidX = (points[2].x + points[3].x) / 2;
                    const bottomMidY = (points[2].y + points[3].y) / 2;
                    const equal3a = document.getElementById('equal3a');
                    const equal3b = document.getElementById('equal3b');
                    if (equal3a && equal3b) {
                        equal3a.setAttribute('x1', bottomMidX - 5);
                        equal3a.setAttribute('y1', bottomMidY + 3);
                        equal3a.setAttribute('x2', bottomMidX + 5);
                        equal3a.setAttribute('y2', bottomMidY + 3);
                        equal3b.setAttribute('x1', bottomMidX - 5);
                        equal3b.setAttribute('y1', bottomMidY + 6);
                        equal3b.setAttribute('x2', bottomMidX + 5);
                        equal3b.setAttribute('y2', bottomMidY + 6);
                    }
                    
                    const sidesMarks = document.getElementById('sides-marks');
                    sidesMarks.style.display = 'block';
                    
                    const leftWaistMidX = (points[0].x + points[3].x) / 2;
                    const leftWaistMidY = (points[0].y + points[3].y) / 2;
                    const side1a = document.getElementById('side1a');
                    if (side1a) {
                        side1a.setAttribute('x1', leftWaistMidX - 3);
                        side1a.setAttribute('y1', leftWaistMidY - 3);
                        side1a.setAttribute('x2', leftWaistMidX - 3);
                        side1a.setAttribute('y2', leftWaistMidY + 3);
                    }
                    
                    const rightWaistMidX = (points[1].x + points[2].x) / 2;
                    const rightWaistMidY = (points[1].y + points[2].y) / 2;
                    const side2a = document.getElementById('side2a');
                    const side2b = document.getElementById('side2b');
                    if (side2a && side2b) {
                        side2a.setAttribute('x1', rightWaistMidX + 3);
                        side2a.setAttribute('y1', rightWaistMidY - 3);
                        side2a.setAttribute('x2', rightWaistMidX + 3);
                        side2a.setAttribute('y2', rightWaistMidY + 3);
                        side2b.setAttribute('x1', rightWaistMidX + 6);
                        side2b.setAttribute('y1', rightWaistMidY - 3);
                        side2b.setAttribute('x2', rightWaistMidX + 6);
                        side2b.setAttribute('y2', rightWaistMidY + 3);
                    }
                } else {
                    const sidesMarks = document.getElementById('sides-marks');
                    if (sidesMarks) {
                        sidesMarks.style.display = 'none';
                    }
                    
                    for (let i = 1; i <= 4; i++) {
                        const equalA = document.getElementById(`equal${i}a`);
                        const equalB = document.getElementById(`equal${i}b`);
                        if (equalA && equalB) {
                            equalA.setAttribute('x1', 0);
                            equalA.setAttribute('y1', 0);
                            equalA.setAttribute('x2', 0);
                            equalA.setAttribute('y2', 0);
                            equalB.setAttribute('x1', 0);
                            equalB.setAttribute('y1', 0);
                            equalB.setAttribute('x2', 0);
                            equalB.setAttribute('y2', 0);
                        }
                    }
                    
                    if (shapeName === 'rectangle' || shapeName === 'parallelogram') {
                        const topMidX = (points[0].x + points[1].x) / 2;
                        const topMidY = (points[0].y + points[1].y) / 2;
                        const equal1a = document.getElementById('equal1a');
                        if (equal1a) {
                            equal1a.setAttribute('x1', topMidX - 5);
                            equal1a.setAttribute('y1', topMidY - 3);
                            equal1a.setAttribute('x2', topMidX + 5);
                            equal1a.setAttribute('y2', topMidY - 3);
                        }
                        
                        const bottomMidX = (points[2].x + points[3].x) / 2;
                        const bottomMidY = (points[2].y + points[3].y) / 2;
                        const equal3a = document.getElementById('equal3a');
                        if (equal3a) {
                            equal3a.setAttribute('x1', bottomMidX - 5);
                            equal3a.setAttribute('y1', bottomMidY + 3);
                            equal3a.setAttribute('x2', bottomMidX + 5);
                            equal3a.setAttribute('y2', bottomMidY + 3);
                        }
                        
                        const leftMidX = (points[0].x + points[3].x) / 2;
                        const leftMidY = (points[0].y + points[3].y) / 2;
                        const equal2a = document.getElementById('equal2a');
                        const equal2b = document.getElementById('equal2b');
                        if (equal2a && equal2b) {
                            equal2a.setAttribute('x1', leftMidX - 3);
                            equal2a.setAttribute('y1', leftMidY - 3);
                            equal2a.setAttribute('x2', leftMidX - 3);
                            equal2a.setAttribute('y2', leftMidY + 3);
                            equal2b.setAttribute('x1', leftMidX - 6);
                            equal2b.setAttribute('y1', leftMidY - 3);
                            equal2b.setAttribute('x2', leftMidX - 6);
                            equal2b.setAttribute('y2', leftMidY + 3);
                        }
                        
                        const rightMidX = (points[1].x + points[2].x) / 2;
                        const rightMidY = (points[1].y + points[2].y) / 2;
                        const equal4a = document.getElementById('equal4a');
                        const equal4b = document.getElementById('equal4b');
                        if (equal4a && equal4b) {
                            equal4a.setAttribute('x1', rightMidX + 3);
                            equal4a.setAttribute('y1', rightMidY - 3);
                            equal4a.setAttribute('x2', rightMidX + 3);
                            equal4a.setAttribute('y2', rightMidY + 3);
                            equal4b.setAttribute('x1', rightMidX + 6);
                            equal4b.setAttribute('y1', rightMidY - 3);
                            equal4b.setAttribute('x2', rightMidX + 6);
                            equal4b.setAttribute('y2', rightMidY + 3);
                        }
                    } else {
                        for (let i = 0; i < 4; i++) {
                            const p1 = points[i];
                            const p2 = points[(i + 1) % 4];
                            const midX = (p1.x + p2.x) / 2;
                            const midY = (p1.y + p2.y) / 2;
                            
                            const equalA = document.getElementById(`equal${i + 1}a`);
                            const equalB = document.getElementById(`equal${i + 1}b`);
                            
                            if (equalA && equalB) {
                                if (i % 2 === 0) {
                                    equalA.setAttribute('x1', midX - 3);
                                    equalA.setAttribute('y1', midY - 3);
                                    equalA.setAttribute('x2', midX + 3);
                                    equalA.setAttribute('y2', midY - 3);
                                    equalB.setAttribute('x1', midX - 3);
                                    equalB.setAttribute('y1', midY + 3);
                                    equalB.setAttribute('x2', midX + 3);
                                    equalB.setAttribute('y2', midY + 3);
                                } else {
                                    equalA.setAttribute('x1', midX - 3);
                                    equalA.setAttribute('y1', midY - 3);
                                    equalA.setAttribute('x2', midX - 3);
                                    equalA.setAttribute('y2', midY + 3);
                                    equalB.setAttribute('x1', midX + 3);
                                    equalB.setAttribute('y1', midY - 3);
                                    equalB.setAttribute('x2', midX + 3);
                                    equalB.setAttribute('y2', midY + 3);
                                }
                            }
                        }
                    }
                }
            } else {
                const sidesMarks = document.getElementById('sides-marks');
                if (sidesMarks) {
                    sidesMarks.style.display = 'none';
                }
            }

            // 設置對角線
            if (shape.visualElements.diagonal.show) {
                const diagonalMarks = document.getElementById('diagonal-marks');
                diagonalMarks.style.display = 'block';
                
                const diagonal1 = document.getElementById('diagonal1');
                const diagonal2 = document.getElementById('diagonal2');
                if (diagonal1 && diagonal2) {
                    diagonal1.setAttribute('x1', points[0].x);
                    diagonal1.setAttribute('y1', points[0].y);
                    diagonal1.setAttribute('x2', points[2].x);
                    diagonal1.setAttribute('y2', points[2].y);
                    
                    diagonal2.setAttribute('x1', points[1].x);
                    diagonal2.setAttribute('y1', points[1].y);
                    diagonal2.setAttribute('x2', points[3].x);
                    diagonal2.setAttribute('y2', points[3].y);
                }
            }
        }

        function highlightVisualElement(visualType) {
            document.querySelectorAll('.visual-element').forEach(el => {
                el.classList.remove('highlight');
            });

            let targetElement = null;
            switch(visualType) {
                case 'parallel':
                    targetElement = document.getElementById('parallel-marks');
                    break;
                case 'equal':
                    targetElement = document.getElementById('equal-marks');
                    break;
                case 'equal-sides':
                    targetElement = document.getElementById('sides-marks');
                    break;
                case 'right-angle':
                    targetElement = document.getElementById('angle-marks');
                    break;
                case 'general-angle':
                    targetElement = document.getElementById('angle-marks-general');
                    break;
                case 'diagonal':
                    targetElement = document.getElementById('diagonal-marks');
                    break;
            }
            
            if (targetElement) {
                targetElement.style.display = 'block';
                targetElement.classList.add('highlight');
            }
        }

        function clearVisualHighlights() {
            document.querySelectorAll('.visual-element').forEach(el => {
                el.classList.remove('highlight');
            });
        }

        function displayShape(shapeName) {
            if (isAnimating) return;
            
            const shape = shapes[shapeName];
            if (!shape) return;
            
            const polygon = document.getElementById('main-shape');
            const title = document.getElementById('shape-title');
            const propertiesList = document.getElementById('properties-list');

            polygon.classList.add('morphing');
            
            setTimeout(() => {
                polygon.setAttribute('points', shape.points);
                polygon.classList.remove('morphing');
                updateVisualMarkers(shapeName);
            }, 200);

            title.textContent = shape.title;
            clearVisualHighlights();
            
            propertiesList.innerHTML = '';
            shape.properties.forEach((prop, index) => {
                setTimeout(() => {
                    const propertyDiv = document.createElement('div');
                    propertyDiv.className = 'property';
                    propertyDiv.style.transform = 'translateX(0)';
                    propertyDiv.style.opacity = '1';
                    propertyDiv.innerHTML = `
                        <div class="property-icon ${prop.icon}"></div>
                        <span>${prop.text}</span>
                    `;
                    
                    propertyDiv.addEventListener('click', () => {
                        document.querySelectorAll('.property').forEach(p => {
                            p.classList.remove('highlight');
                        });
                        
                        propertyDiv.classList.add('highlight');
                        
                        if (prop.visual) {
                            highlightVisualElement(prop.visual);
                        }
                    });
                    
                    propertiesList.appendChild(propertyDiv);
                }, index * 200);
            });

            currentShape = shapeName;
        }

        // 新增：動畫變換函數
        function animateTransformation(sourceShape, targetShape) {
            if (isAnimating) return;
            
            isAnimating = true;
            animationState.isActive = true;
            animationState.sourceShape = sourceShape;
            animationState.targetShape = targetShape;
            
            const polygon = document.getElementById('main-shape');
            const progressBar = document.querySelector('.progress-bar');
            const animateBtn = document.getElementById('animate-transformation-btn');
            const progressContainer = document.querySelector('.transformation-progress');
            
            // 隐藏按钮，显示进度条
            animateBtn.style.display = 'none';
            progressContainer.style.display = 'block';
            
            // 獲取起始和目標點
            const sourcePoints = shapes[sourceShape].points.split(' ').map(p => {
                const [x, y] = p.split(',').map(Number);
                return { x, y };
            });
            
            const targetPoints = shapes[targetShape].points.split(' ').map(p => {
                const [x, y] = p.split(',').map(Number);
                return { x, y };
            });
            
            // 設置起始形狀
            polygon.setAttribute('points', shapes[sourceShape].points);
            updateVisualMarkers(sourceShape);
            
            // 動畫參數
            const duration = 3000; // 3秒動畫
            const steps = 60; // 60幀
            const stepDuration = duration / steps;
            let currentStep = 0;
            
            // 添加變換動畫類
            polygon.classList.add('transforming');
            
            const animationInterval = setInterval(() => {
                const progress = currentStep / steps;
                
                // 更新進度條
                progressBar.style.width = `${progress * 100}%`;
                
                // 計算當前幀的點坐標（線性插值）
                const currentPoints = sourcePoints.map((point, index) => {
                    const targetPoint = targetPoints[index];
                    const x = point.x + (targetPoint.x - point.x) * progress;
                    const y = point.y + (targetPoint.y - point.y) * progress;
                    return `${x},${y}`;
                }).join(' ');
                
                polygon.setAttribute('points', currentPoints);
                
                // 更新視覺標記（在中間階段逐漸過渡）
                if (progress < 0.3) {
                    updateVisualMarkers(sourceShape);
                } else if (progress > 0.7) {
                    updateVisualMarkers(targetShape);
                } else {
                    // 中間階段：部分標記可能消失或出現
                    updateVisualMarkers(sourceShape);
                }
                
                currentStep++;
                
                if (currentStep > steps) {
                    clearInterval(animationInterval);
                    
                    // 動畫完成
                    polygon.setAttribute('points', shapes[targetShape].points);
                    polygon.classList.remove('transforming');
                    polygon.classList.add('animating');
                    
                    // 更新到目標形狀
                    updateVisualMarkers(targetShape);
                    
                    // 更新形狀信息
                    displayShape(targetShape);
                    updateActiveShape(targetShape);
                    
                    // 恢復按鈕狀態
                    setTimeout(() => {
                        progressContainer.style.display = 'none';
                        progressBar.style.width = '0%';
                        animateBtn.style.display = 'inline-block';
                        
                        polygon.classList.remove('animating');
                        isAnimating = false;
                        animationState.isActive = false;
                    }, 500);
                }
            }, stepDuration);
        }

        // 形状交互状态
        let interactionState = {
            sourceShape: null,
            isSelectingTarget: false
        };

        // 变换关系定义
        const transformationPaths = {
            'trapezoid-parallelogram': '讓另一組對邊也變平行',
            'parallelogram-rectangle': '將所有角度都變為直角', 
            'parallelogram-rhombus': '將四條邊都變為相等',
            'rectangle-square': '將四條邊都變為相等',
            'rhombus-square': '將四個角都變為直角',
            'rectangle-rhombus': '改變角度，讓對角不再都是直角，同時調整邊長比例',
            'rhombus-rectangle': '將四個角都變為直角，同時調整邊長比例',
            'parallelogram-trapezoid': '讓一組對邊不再平行',
            'rectangle-parallelogram': '改變角度，不再都是直角',
            'rhombus-parallelogram': '改變邊長，不再都相等', 
            'square-rectangle': '改變邊長比例，長寬不相等',
            'square-rhombus': '改變角度，不再都是直角',
            'trapezoid-rectangle': '先讓另一組對邊變平行成為平行四邊形，再將所有角度變為直角',
            'trapezoid-rhombus': '先讓另一組對邊變平行成為平行四邊形，再將四條邊都變為相等',
            'trapezoid-square': '先變為平行四邊形，再通過長方形或菱形的路徑最終變為正方形',
            'rectangle-trapezoid': '先改變角度變為平行四邊形，再讓一組對邊不再平行',
            'rhombus-trapezoid': '先改變邊長變為平行四邊形，再讓一組對邊不再平行',
            'square-trapezoid': '先退化為長方形或菱形，再變為平行四邊形，最後讓一組對邊不再平行',
            'square-parallelogram': '改變邊長比例或角度，失去正方形的完美對稱性'
        };

        function getTransformationDescription(sourceShape, targetShape) {
            const transformKey = `${sourceShape}-${targetShape}`;
            return transformationPaths[transformKey] || '無法直接變換，請選擇其他路徑';
        }

        function handleShapeSelection(shapeName) {
            const shapeNode = document.querySelector(`.shape-node[data-shape="${shapeName}"]`);
            
            if (!interactionState.isSelectingTarget) {
                resetShapeSelection();
                interactionState.sourceShape = shapeName;
                interactionState.isSelectingTarget = true;
                
                shapeNode.classList.add('active');
                shapeNode.style.backgroundColor = '#4CAF50';
                
                const relationshipInfo = document.querySelector('.relationship-info');
                const relationshipText = document.getElementById('relationship-text');
                const animateBtn = document.getElementById('animate-transformation-btn');
                
                relationshipInfo.classList.remove('hidden');
                relationshipInfo.classList.remove('transformation');
                relationshipText.textContent = `✨ 已選擇 ${shapes[shapeName].title}，請點擊目標形狀查看變換方式`;
                animateBtn.style.display = 'none';
                
            } else if (shapeName === interactionState.sourceShape) {
                resetShapeSelection();
                
            } else {
                const sourceShape = interactionState.sourceShape;
                const targetShape = shapeName;
                
                shapeNode.classList.add('active');
                shapeNode.style.backgroundColor = '#FF6B6B';
                
                const description = getTransformationDescription(sourceShape, targetShape);
                const relationshipInfo = document.querySelector('.relationship-info');
                const relationshipText = document.getElementById('relationship-text');
                const animateBtn = document.getElementById('animate-transformation-btn');
                
                relationshipInfo.classList.remove('hidden');
                relationshipInfo.classList.add('transformation');
                relationshipText.innerHTML = `
                    <strong>${shapes[sourceShape].title} → ${shapes[targetShape].title}</strong><br>
                    ${description}
                `;
                
                // 顯示動畫按鈕
                animateBtn.style.display = 'inline-block';
                animateBtn.onclick = () => {
                    animateTransformation(sourceShape, targetShape);
                };
                
                interactionState.isSelectingTarget = false;
                interactionState.sourceShape = null;
            }
        }

        function resetShapeSelection() {
            interactionState.sourceShape = null;
            interactionState.isSelectingTarget = false;
            
            document.querySelectorAll('.shape-node').forEach(node => {
                node.classList.remove('active');
                node.style.backgroundColor = '';
            });
            
            const relationshipInfo = document.querySelector('.relationship-info');
            const relationshipText = document.getElementById('relationship-text');
            const animateBtn = document.getElementById('animate-transformation-btn');
            const progressContainer = document.querySelector('.transformation-progress');
            
            relationshipInfo.classList.add('hidden');
            relationshipInfo.classList.remove('transformation');
            relationshipText.textContent = '💡 點擊一個形狀作為起點，再點擊另一個形狀查看變換方式';
            animateBtn.style.display = 'none';
            progressContainer.style.display = 'none';
        }

        function updateActiveShape(shapeName) {
            document.querySelectorAll('.shape-btn').forEach(b => b.classList.remove('active'));
            const btn = document.querySelector(`[data-shape="${shapeName}"]`);
            if (btn) btn.classList.add('active');
        }

        // Event listeners
        document.addEventListener('DOMContentLoaded', function() {
            document.querySelectorAll('.shape-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    updateActiveShape(btn.dataset.shape);
                    displayShape(btn.dataset.shape);
                });
            });

            document.querySelectorAll('.shape-node').forEach(node => {
                node.addEventListener('click', (e) => {
                    e.stopPropagation();
                    
                    handleShapeSelection(node.dataset.shape);
                    updateActiveShape(node.dataset.shape);
                    displayShape(node.dataset.shape);
                });
            });

            document.addEventListener('click', (e) => {
                if (!e.target.closest('.shape-node') && 
                    !e.target.closest('.relationship-info') &&
                    !e.target.closest('.property') &&
                    !e.target.closest('#animate-transformation-btn') &&
                    !e.target.closest('.transformation-progress')) {
                    
                    if (interactionState.isSelectingTarget) {
                        resetShapeSelection();
                    }
                    
                    document.querySelectorAll('.property').forEach(p => {
                        p.classList.remove('highlight');
                    });
                    clearVisualHighlights();
                }
            });

            displayShape('square');
            updateActiveShape('square');
            resetShapeSelection();
        });
    </script>
</body>
</html>